from abc import abstractmethod
from dotenv import load_dotenv
from pydantic_ai.tools import Tool
from types import SimpleNamespace
from rich.console import Console
from rich.traceback import Traceback

load_dotenv()
console = Console()


class LLM:
    @abstractmethod
    def __init__(self, system_prompt: str, tools: list[Tool]) -> None:
        """Initialize the LLM with a system prompt.

        Args:
            system_prompt (str): The system prompt to guide the LLM's behavior.
        """

    @abstractmethod
    async def run(self, message: str, context_id: str) -> str:
        """Run the LLM with a given message and context ID.

        Args:
            message (str): The input message to process.
            context_id (str): The context ID for the conversation.

        Returns:
            str: The output generated by the LLM.
        """


class Echo(LLM):
    def __init__(self, system_prompt: str, tools: list[Tool]) -> None:
        """"""

    async def run(self, message: str, context_id: str) -> str:
        return f"echo: {message}"


class Pydantic_LLM(LLM):
    def __init__(self, system_prompt: str, tools: list[Tool]) -> None:
        from pydantic_ai import Agent

        self.llm = Agent("openai:gpt-4o", system_prompt=system_prompt)
        self.contexts = {}

        for tool in tools:
            self.llm._register_tool(tool)

    async def run(self, message: str, context_id: str) -> str:
        if not isinstance(self.contexts.get(context_id), list):
            self.contexts[context_id] = []

        result = None
        try:
            result = await self.llm.run(message, message_history=self.contexts[context_id])
        except Exception as e:
            console.print(Traceback())
            result = SimpleNamespace(output="Error while calling LLM", new_messages=lambda: [])

        self.contexts[context_id].extend(result.new_messages())

        return result.output
